\documentclass[11pt,a4paper]{article}
\usepackage{tabulary}
\usepackage{geometry}
\geometry{
    a4paper,
    total={170mm,257mm},
    left=20mm,
    top=20mm,
}
\usepackage{color}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\SubItem}[1]{
    {\setlength\itemindent{15pt} \item[-] #1}
}

\begin{document}
\title{Polkadot Module Benchmarking}
\author{Web3 Foundation}
\date{April 2020}
\maketitle

\section{Motivation}
Polkadot has a limited time window for block producers to create a block,
including limitations on block size which can make the selection and execution
of certain extrinsics too expensive and decelerate the network. The weight
system introduces a mechanism for block producers to measure the expense of
extrinsics and determine how "heavy" it is. With this mechanism, block producers
can select a set of extrinsics and saturate the block to it's fullest potential
without exceeding any limitations.
\newline

Polkadot also introduces a specified block ratio, ensuring that only a certain
portion of the total block size gets used for regular extrinsics. The remaining
space is reserved for critical, operational extrinsics required for the functionality 
by Polkadot itself.

\section{Weight Assignment}
Assigning weights based on theoretical performance such as big O notation proves to be
unreliable and too complex due to imprecision in back-end systems, internal communication
within the Runtime and design choices in the software. Therefore, all available Runtime 
functions, which create and execute extrinsics, have to be benchmarked with a large
collection of input parameters.

\subsection{Parameters}
The inputs parameters highly vary depending on the Runtime function and must therefore
be carefully selected. The benchmarks should use parameters which will most likely be
used in regular cases, as intended by the authors, but must also consider worst case
scenarios and inputs which might decelerate or heavily impact performance of the function.
The input parameters should be randomized in order to cause various effects in behaviors
on certain values, such as memory relocations and other results that can impact performance.

\subsection{Blockchain State}
The benchmarks should be performed on blockchain states that already contain a history of
extrinsics and storage changes. Runtime functions that required read/writing on structures
such as Tries will therefore produce more realistic results that will reflect the real-world
performance of the Runtime.

\subsection{Environment}
The benchmarks should be executed on clean systems without interference of other processes
or software. Additionally, the benchmarks should be executed multiple machines with different
system resources, such as CPU performance, CPU cores, RAM and storage speed.

\section{Fundamentals}
Block producers should be able to quickly determine a weight for an extrinsic before executing it.
Weights are just a numeric value and Runtime functions may use complex structures to express those
vaules. Therefore, the following points must apply for weight calculations:
\begin{itemize}
\item Computations of weights must be determined before execution of that extrinsic.
\item Due to the limited time window, computations of weights must be done quickly and consume
      few resources itself.
\item Weights must be self contained and must not require I/O on the chain state. Weights are
      fixed measurements and are based solely on the Runtime function and its parameters.
\end{itemize}

\section{Limitations}

\section{Chosen Parameters for Polkadot}
This section describes the chosen parameters for the Polkadot Runtime functions.\todo{tag/revision}

\subsection{Balances}

\subsubsection*{Variables per benchmark}
\begin{itemize}
\item INDEX in 1 to 1000
\item BALANCE in 2 to 1000
\end{itemize}

\subsubsection{transfer\_worst\_case}

Benchmark \verb|transfer| with the worst possible conditions:
\begin{itemize}
\item Transfer will kill the origin account.
\item Transfer will create the destination account.
\end{itemize}

\subsubsection*{Environment preparation}
\begin{itemize}
\item Origin account balance: BALANCE
\item Destination account balance: none
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    transfer(origin, destination, value)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
\item Account name: "caller"
\item Account index: INDEX
\item Seed: 0
\end{itemize}
\verb|destination|
\begin{itemize}
\item Account name: "recipient"
\item Account index: INDEX
\item Seed: 0
\end{itemize}
\verb|value|
\begin{itemize}
\item Balance: BALANCE
\end{itemize}

\subsubsection{transfer\_best\_case}

Benchmark \verb|transfer| with the best possible conditions:
\begin{itemize}
\item Origin account already exists and will continue to exists.
\item Destination account already exists and will continue to exists.
\end{itemize}

\subsubsection*{Environment preparation}
\begin{itemize}
\item Origin account balance: max balance
\item Destination account balance: existential deposit
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    transfer(origin, destination, value)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
\item Account name: "caller"
\item Account index: INDEX
\item Seed: 0.
\end{itemize}
\verb|destination|
\begin{itemize}
\item Account name: "recipient"
\item Account index: INDEX
\item Seed: 0
\end{itemize}
\verb|value|
\begin{itemize}
\item Balance: BALANCE
\end{itemize}

\subsubsection{transfer\_keep\_alive}

Benchmark \verb|transfer_keep_alive| with the worst possible conditions:
\begin{itemize}
\item Destination account is created.
\end{itemize}

\subsubsection*{Environment preparation}
\begin{itemize}
\item Origin account balance: max balance
\item Destination account balance: none
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    transfer_keep_alive(origin, destination, value)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
\item Account name: "caller"
\item Account index: INDEX
\item Seed: 0.
\end{itemize}
\verb|destination|
\begin{itemize}
\item Account name: "recipient"
\item Account index: INDEX
\item Seed: 0
\end{itemize}
\verb|value|
\begin{itemize}
\item Balance: BALANCE
\end{itemize}

\subsubsection{set\_balance}

Benchmark \verb|set_balance| coming from ROOT account, which results in account creation.

\subsubsection*{Environment preparation}
\begin{itemize}
\item Origin account balance: max balance
\item Destination account balance: none
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    set_balance(origin, destination, free_value, reserved_value)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
\item Account name: ROOT
\end{itemize}
\verb|destination|
\begin{itemize}
\item Account name: "user"
\item Account index: INDEX
\item Seed: 0
\end{itemize}
\verb|free_value|
\begin{itemize}
\item Balance: BALANCE
\end{itemize}
\verb|reserved_value|
\begin{itemize}
\item Balance: BALANCE
\end{itemize}

\subsubsection{set\_balance\_killing}

Benchmark \verb|set_balance| coming from ROOT account, which results in account termination.

\subsubsection*{Environment preparation}
\begin{itemize}
    \item Origin account free balance: BALANCE
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    set_balance(origin, who, free_value, reserved_value)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
    \item Account name: ROOT
\end{itemize}
\verb|destination|
\begin{itemize}
    \item Account name: "user"
    \item Account index: INDEX
    \item Seed: 0
\end{itemize}
\verb|free_value|
\begin{itemize}
    \item Balance: 0
\end{itemize}
\verb|reserved_value|
\begin{itemize}
    \item Balance: 0
\end{itemize}

\subsection{Democracy}

\subsubsection*{Variables per benchmark}
\begin{itemize}
\item MAX\_USERS in 1 to 1000
\item MAX\_REFERENDUMS in 1 to 100
\item MAX\_PROPOSALS in 1 to 100
\end{itemize}

\subsubsection{propose}

Benchmark \verb|propose|.

\subsubsection*{Environment preparation}
\begin{itemize}
    \item Origin account free balance: max balance
    \item Create MAX\_PROPOSALS of proposals
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    propose(origin, proposal_hash, value)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
    \item Account name: "caller"
    \item Account index: 0 
    \item Seed: 0
\end{itemize}
\verb|proposal_hash|
\begin{itemize}
    \item Hash of proposal: MAY\_PROPOSALS
\end{itemize}
\verb|value|
\begin{itemize}
    \item Balance: minimum deposit
\end{itemize}

\subsubsection{second}

Benchmark \verb|second|.

\subsubsection*{Iterations}
\begin{itemize}
    \item SECOND\_AMOUNT in 0 to 100
\end{itemize}

\subsubsection*{Environment preparation}
\begin{itemize}
    \item Origin account free balance: max balance
    \item Create SECOND\_AMOUNT of "seconds"
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    second(origin, proposal_index)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
    \item Account name: "caller"
    \item Account index: 0 
    \item Seed: 0
\end{itemize}
\verb|proposal_index|
\begin{itemize}
    \item Index: 0
\end{itemize}

\subsubsection{vote}

Benchmark \verb|vote|.

\subsubsection*{Iterations}
\begin{itemize}
    \item MAX\_REFERENDUMS in 1 to 100
\end{itemize}

\subsubsection*{Environment preparation}
\begin{itemize}
    \item Origin account free balance: max balance
    \item Create MAY\_REFERENDUMS of referendums
\end{itemize}

\subsubsection*{Function prototype}
\begin{verbatim}
    vote(origin, ref_index, vote)
\end{verbatim}

\subsubsection*{Properties}
\verb|origin|
\begin{itemize}
    \item Account name: "caller"
    \item Account index: 0 
    \item Seed: 0
\end{itemize}
\verb|ref_index|
\begin{itemize}
    \item Index: 0
\end{itemize}
\verb|vote|
\begin{itemize}
    \item Aye: true
    \item Conviction: 
\end{itemize}

\end{document}