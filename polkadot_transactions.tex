\documentclass[11pt,a4paper]{article}
\usepackage{tabulary}
\usepackage{geometry}
\geometry{
    a4paper,
    total={170mm,257mm},
    left=20mm,
    top=20mm,
}
\usepackage{color}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\SubItem}[1]{
    {\setlength\itemindent{15pt} \item[-] #1}
}

\begin{document}
\title{Polkadot Runtime Specification}
\author{Web3 Foundation}
\date{February 2020}
\maketitle

\section{Weights}
Polkadot blocks have a limited window for block producers to create a block,
limited amount of data that can be included per block and overall practical limit
to storage footprint of the blockchain. Therefore, Polkadot has introduced a Weight
system that tells block producers how "heavy" an extrinsic is. Given the maximum
block weight, and the weight of the individual extrinsic in a transaction pool,
the block producer can select a set of extrinsics that allows them to saturate the
block while not going over the limits.
\newline

Additionally, Polkadot has introduced an available block ratio which ensures that
only a portion of the total maximum block weight is used for regular transactions.
This also introduces the concept of operational transactions which are system
critical operations that can use the rest of the available block weight.
\todo{define operational transactions}

\subsection*{Example}
Considering the maximum block weight is 1'000'000, the weight of
individual transactions is 1'000 and the available block ration is 80\%,
about 800 transfers per block could be possible.

\begin{verbatim}
    1'000'000 * .80 / 1'000 = 800 transfers per block
\end{verbatim}

\subsection{Fees}
To bring the weight system to the users of Polkadot, a tightly couples fee system
is introduced. Users will pay a transaction fee proportional to the weight of the
call they are making.

\begin{verbatim}
    total_fee = base_fee + length_fee + weight_fee
\end{verbatim}

\todo{explain more about fees: base fee, length, define types, etc.}

\subsection{Documentation of Weights}
Functions should contain Documentation about the computational and resource complexity.
The result of weight documentation is to arrive at the final order of a function
in terms of Big-O notation.

\subsubsection{What to document}
The document should include information about the runtime functions which have notable
execution costs. This includes:

\begin{itemize}
\item Storage Operations (read, write, mutate, etc.)
\item Codec Operations (serializing/deserializing)
\item Search / Sort / Notable computation
\item Calls to other functions
\end{itemize}

\subsubsection{Storage and Codec Operations}
Accessing storage is a heavy operation, and one that should be well documented and
optimized in favor writing “functional code”. Each storage operation should be
documented with the relative codec complexity of interacting with that storage.
\newline

For example, if you are reading a vector of members from a single value storage
item, the weight documentation should read:
\newline

\texttt{- One storage read to get the members of this pallet: `O(M)`.}
\newline

In this case reading the vector from storage has a codec complexity of \texttt{O(M)}
to deserialize the \texttt{M} member accounts in the vector. Later in your module,
you might go ahead and write the data back into the runtime, which should also be
documented:
\newline

\texttt{- One storage write to update the members of this pallet: `O(M)`.}

\subsubsection{Search / Sort / Notable Computations}
When searching or sorting in the runtime module, it is also important to note
the relative complexity of those operations.
\newline

For example, when searching for an item in a sorted list, a binary\_search
operation should take \texttt{O(logM)}, while an unsorted list, should take
\texttt{O(M)}.
\newline

\texttt{- Insert a new member into sorted list: O(logM).}
\newline

This kind of documentation should be present for any sort of notable heavy
computation present in the logic.

\subsubsection{Calls to other functions}

If a other functions get called, one should take note of that and assign these calls
with their own variable.
\newline

\todo{}
For example, when a function reserves some balance in the Balances pallet or emits
an event through the System pallet, you should document:
\newline

\todo{}
- One balance reserve operation: O(B)
- One event emitted: O(E)

\subsubsection{Combining the data}
Once you have good documentation for your runtime function, you need to consolidate
it into a single overall order of the function.Lets combine the different example
operations to create a full end to end example.

Note: You may have introduced multiple different variables into your overall
weight documentation, so be sure to document what these variables represent.

If you look at this example, you can see we had two operations that were O(M)
(the storage read and write), but our overall order does not take this into account.

When doing empirical testing, we are unable to separate complexities which have the
same order. This means that there could be many many more operations added to this
function, of order O(M), O(logM), etc… but it would not change our final formula
as a function of M, B, and E:

weight(M, B, E) = K\_1 + K\_2 * M + K\_3 * logM + B + E

The difference between two functions with the same order will be empirically
measured through on-chain tests. The goal of this step is to simply derive the
coefficients (K) that we will be searching for when we do the next step.

\subsubsection{Temporary Weight Annotation}
\todo{}

\subsubsection{Measuring Weights}
\todo{}

\section{Polkadot Transactions}
\section*{Summary}
\begin{center}
  \begin{tabulary}{1.0\textwidth}{LLLL}
    \textbf{Module} & \textbf{Function} & \textbf{Weight} & \textbf{Description} \\
    \hline
    Attestations & more\_attestations & None & Provide candidate receipts \\
    Claims & deposit\_event & None & Deposit one of this module's events \\
    Claims & claim & 1'000'000 & Make a claim \\
    Claims & mint\_claim & 30'000 & Add a new claim, if you are root \\
    Crowdfund & deposit\_event & None & Deposit one of this modules's events \\
    Crowdfund & create & 100'000 & Create a new campaign  \\
    Crowdfund & contribute & None & Contribute to a crowd sale \\
    Crowdfund & fix\_deploy\_data & None & Set the deploy data of funded parachain \\
    Crowdfund & onboard & None & Complete onboarding process \\
    Crowdfund & begin\_retirement & None & Retire a fund when it has lost its slot \\
    Crowdfund & withdraw & None & Withdraw full balance \\
    Crowdfund & dissolve & None & Remove a fund \\
    Parachains & set\_heads & 1'000'000 & Provide candidate receipts \\
    Registrar & deposit\_event & None & Deposit one of this module's events \\
    Registrar & register\_para & 5'000,000 & Register a parachain with given code \\
    Registrar & deregister\_para & 10'000 & Deregister a parachain \\
    Registrar & set\_thread\_count & None & Reset the number of parathreads \\
    Registrar & register\_parathread & None & Register a parathread for immediate use \\
    Registrar & select\_parathread & None & Place a bid to progress parathread \\
    Registrar & deregister\_parathread & None & Deregister a parathread \\
    Registrar & swap & None & Swap a parachain with another \\
    Slots & deposit\_event & None & Deposit one of this module's events \\
    Slots & new\_auction & 100'000 & Create a new aution \\
    Slots & bid & 500'000 & Make a new bid for deploying \\
    Slots & bid\_renew & 500'000 & Make a new bid for renewing \\
    Slots & set\_offboarding & 1'000'000 & Set the off-boarding information \\
    Slots & fix\_deploy\_data & 500'000 & Set the information for deployment \\
    Slots & elaborate\_deploy\_data & 5'000'000 & Note a new parachains's code \\
  \end{tabulary}
\end{center}
\newpage

\subsection{Attestations}
\subsubsection{more\_attestations}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func more_attestations
        (param $origin) (param $more) (return dispatch))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Provide candidate receipts for parachains, in ascending order by id.

\subsection{Claims}
\subsubsection{deposit\_event}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func deposit_event 
        (param $origin) (param $more))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Deposit one of this module's events by using the default implementation.

\subsubsection{claim}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func claim
        (param $origin) (param $dest) (param $sig))
\end{verbatim}
\subsubsection*{Weight}
Weight: 1'000'000
\subsubsection*{Description}
Make a claim.

\subsubsection{mint\_claim}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func mint_claim
        (param $origin) (param $who) (param $value) (param $vesting_schedule))
\end{verbatim}
\subsubsection*{Weight}
Weight: 30'000
\subsubsection*{Description}
Add a new claim, if you are root.

\subsection{Crowdfund}
\subsubsection{deposit\_event}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func deposit_event)
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Deposit one of this module's events by using the default implementation.

\subsubsection{create}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func create 
        (param $origin) (param $cap) (param $first_slot)
        (param $last_slot) (param $end))
\end{verbatim}
\subsubsection*{Weight}
Weight: 100'000
\subsubsection*{Description}
Create a new crowdfunding campaign for a parachain slot deposit for the current auction. 

\subsubsection{contribute}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func contribute
        (param $origin) (param $index) (param $value))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Contribute to a crowd sale. This will transfer some balance over to fund a parachain slot. It will be withdrawable in two instances: the parachain becomes retired; or the slot is.

\subsubsection{fix\_deploy\_data}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func fix_deploy_data
        (param $origin) (param $index) (param $code_hash)
        (param $initial_head_data))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Set the deploy data of the funded parachain if not already set. Once set, this cannot be changed again.

\begin{itemize}
\item \verb|origin| must be the fund owner.
\item \verb|index| is the fund index that origin owns and whose deploy data will be set.
\item \verb|code_hash| is the hash of the parachain's Wasm validation function.
\item \verb|initial_head_data| is the parachain's initial head data.
\end{itemize}

\subsubsection{onboard}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func onboard
        (param $origin) (param $index) (param $para_id))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Complete onboarding process for a winning parachain fund. This can be called once by any origin once a fund wins a slot and the fund has set its deploy data (using \verb|fix_deploy_data|).

\begin{itemize}
\item \verb|index| is the fund index that origin owns and whose deploy data will be set.
\item \verb|para_id| is the parachain index that this fund won.
\end{itemize}

\subsubsection{begin\_retirement}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func begin_retirement
        (param $origin) (param $index))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Note that a successful fund has lost its parachain slot, and place it into retirement.

\subsubsection{withdraw}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func withdraw
        (param $origin) (param $index))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Withdraw full balance of a contributor to an unsuccessful or off-boarded fund.

\subsubsection{dissolve}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func dissolve
        (param $origin) (param $index))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Remove a fund after either: it was unsuccessful and it timed out; or it was successful but it has been retired from its parachain slot. This places any deposits that were not withdrawn into the treasury.

\subsection{Parachains}
\subsubsection{set\_heads}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func set_heads
        (param $origin) (param $heads) (return dispatch))
\end{verbatim}
\subsubsection*{Weight}
Weight: 1'000'000
\subsubsection*{Description}
Provide candidate receipts for parachains, in ascending order by id.

\subsection{Registrar}
\subsubsection{deposit\_event}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func deposit_event)
\end{verbatim}
\subsubsection*{Weight}
Weight: None 
\subsubsection*{Description}
Deposit one of this module's events by using the default implementation.

\subsubsection{register\_para}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func register_para
        (param $origin) (param $id) (param $info)
        (param $code) (param $initial_head_data)
        (return dispatch))
\end{verbatim}
\subsubsection*{Weight}
Weight: 5'000'000 
\subsubsection*{Description}
Register a parachain with given code. Fails if given ID is already used.

\subsubsection{deregister\_para}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func deregister_para
        (param $origin) (param $id) (return dispatch))
\end{verbatim}
\subsubsection*{Weight}
Weight: 10'000 
\subsubsection*{Description}
Deregister a parachain with given id.

\subsubsection{set\_thread\_count}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func set_thread_count
        (param $origin) (param $count))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Reset the number of parathreads that can pay to be scheduled in a single block.
\begin{itemize}
\item \verb|count| is the number of parathreads.
\end{itemize}
Must be called from Root origin.

\subsubsection{register\_parathread}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func register_parathread
        (param $origin) (param $code) (param $initial_head_data)
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Register a parathread for immediate use. Must be sent from a Signed origin that is able to have ParathreadDeposit reserved. \verb|code| and \verb|initial_head_data| are used to initialize the parathread's state.

\subsubsection{select\_parathread}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func select_parathread
        (param $origin) (param $id)
        (param $collator) (param $head_hash))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Place a bid for a parathread to be progressed in the next block. This is a kind of special transaction that should be heavily prioritized in the transaction pool according to the `value`; only `ThreadCount` of them may be presented in any single block.

\subsubsection{deregister\_parathread}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func deregister_parathread
        (param $origin))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Deregister a parathread and retrieve the deposit. Must be sent from a Parachain \verb|origin| which is currently a parathread. Ensure that before calling this that any funds you want emptied from the parathread's account is moved out; after this it will be impossible to retrieve them (without governance intervention).

\subsubsection{swap}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func swap
        (param $origin) (param $other))
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Swap a Parachain with another Parachain or parathread. The origin must be a Parachain. The swap will happen only if there is already an opposite swap pending. If there is not, the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
The \verb|ParaId|`s remain mapped to the same head data and code so external code can rely on \verb|ParaId| to be a long-term identifier of a notional Parachain. However, their scheduling info (i.e. whether they're a parathread or parachain), auction information and the auction deposit are switched.

\subsection{Slots}
\subsubsection{deposit\_event}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func deposit_event)
\end{verbatim}
\subsubsection*{Weight}
Weight: None
\subsubsection*{Description}
Deposit one of this module's events by using the default implementation.

\subsubsection{new\_auction}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func new_auction
        (param $origin) (param $duration) (param $lease_period_index))
\end{verbatim}
\subsubsection*{Weight}
Weight: 100'000
\subsubsection*{Description}
Create a new auction. This can only happen when there isn't already an auction in progress and may only be called by the root origin. Accepts the `duration` of this auction and the `lease\_period\_index` of the initial lease period of the four that are to be auctioned.

\subsubsection{bid}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func bid 
        (param $origin) (param $sub) (param $auction_index)
        (param $first_slot) (param $last_slot) (param $amount))
\end{verbatim}
\subsubsection*{Weight}
Weight: 500'000
\subsubsection*{Description}
Make a new bid from an account (including a parachain account) for deploying a new parachain. Multiple simultaneous bids from the same bidder are allowed only as long as all active bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.

\begin{itemize}
\item \verb|sub| is the sub-bidder ID, allowing for multiple competing bids to be made by (and funded by) the same account.
\item \verb|auction_index| is the index of the auction to bid on. Should just be the present value of `AuctionCounter`.
\item \verb|first_slot| is the first lease period index of the range to bid on. This is the absolute lease period index value, not an auction-specific offset.
\item \verb|last_slot| is the last lease period index of the range to bid on. This is the absolute lease period index value, not an auction-specific offset.
\item \verb|amount| is the amount to bid to be held as deposit for the parachain should the bid win. This amount is held throughout the range.
\end{itemize}

\subsubsection{bid\_renew}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func bid_renew
        (param $origin) (param $auction_index) (param $first_slot)
        (param $last_slot) (param $amount))
\end{verbatim}
\subsubsection*{Weight}
Weight: 500'000
\subsubsection*{Description}
Make a new bid from a parachain account for renewing that (pre-existing) parachain. The origin \textbf{must} be a parachain account. Multiple simultaneous bids from the same bidder are allowed only as long as all active bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.

\begin{itemize}
\item \verb|auction_index| is the index of the auction to bid on. Should just be the present value of \verb|AuctionCounter|.
\item \verb|first_slot| is the first lease period index of the range to bid on. This is the absolute lease period index value, not an auction-specific offset.
\item \verb|last_slot| is the last lease period index of the range to bid on. This is the absolute lease period index value, not an auction-specific offset.
\item \verb|amount| is the amount to bid to be held as deposit for the parachain should the bid win. This amount is held throughout the range.
\end{itemize}

\subsubsection{set\_offboarding}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func set_offboarding
        (param $origin) (param $dest))
\end{verbatim}
\subsubsection*{Weight}
Weight: 1'000'000
\subsubsection*{Description}
Set the off-boarding information for a parachain. The origin \textbf{must} be a parachain account.

\begin{itemize}
\item \verb|dest| is the destination account to receive the parachain's deposit.
\end{itemize}

\subsubsection{fix\_deploy\_data}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func fix_deploy_data
        (param $origin) (param $sub) (param $para_id)
        (param $code_hash) (param $initial_head_data))
\end{verbatim}
\subsubsection*{Weight}
Weight: 500'000
\subsubsection*{Description}
Set the deploy information for a successful bid to deploy a new parachain.

\begin{itemize}
\item \verb|origin| must be the successful bidder account.
\item \verb|sub| is the sub-bidder ID of the bidder.
\item \verb|para_id| is the parachain ID allotted to the winning bidder.
\item \verb|code_hash| is the hash of the parachain's Wasm validation function.
\item \verb|initial_head_data| is the parachain's initial head data.
\end{itemize}

\subsubsection{elaborate\_deploy\_data}
\subsubsection*{Prototype:}
\begin{verbatim}
    (func elaborate_deploy_data
        (param $origin) (param $para_id) (param $code))
\end{verbatim}
\subsubsection*{Weight}
Weight: 5'000'000
\subsubsection*{Description}
Note a new parachain's code. This must be called after \verb|fix_deploy_data| and \verb|code| must be the preimage of the \verb|code_hash| passed there for the same \verb|para_id|. This may be called before or after the beginning of the parachain's first lease period. If called before then the parachain will become active at the first block of its starting lease period. If after, then it will become active immediately after this call.

\begin{itemize}
\item \verb|origin| is irrelevant.
\item \verb|para_id| is the parachain ID whose code will be elaborated.
\item \verb|code| is the preimage of the registered \verb|code_hash| of \verb|para_id|.
\end{itemize}

\end{document}